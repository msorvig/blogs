<!DOCTYPE html>
<html>
<meta charset="utf-8">
<link rel="stylesheet" href="../css/blog.css">
    
<h1>Html Document Integration with Qt for WebAssembly</h1>

<p>In my <a href= https://www.qt.io/blog/porting-slate-to-qt-for-webassembly>previous blog</a> we took a look at how to bring the <a href = https://github.com/mitchcurtis/slate>Slate</a> app to the <a href=https://msorvig.github.io/qt-webassembly-examples/slate/slate.html>web</a>, with some pratical pointers on how use web features such as file dialogs and navigate-away warning dialogs.

<p>In this blog we'll take a closer look at how integrate Qt and the web, spesifically at how to embed application windows in web documents. By default, Qt genereates an html file which supports one application window that use entire browser viewport. However this is not the only option. Applications can also provide custom html which supports mixing Qt and web content. To understand how this works we'll take a look at the html document structure, and how Qt interacts with html documents

<h2>Html Document Structure</h2>

<p> Html documents have a size (with and height), and define a coordinate system for placing html elements. This placement is often done automatically by the html layout engine, though placing elements at explicit coordinates using absolute geometry is also possible. The browser displays the document through the viewport - scrolling the web page moves the viewport over the document.

<img src="document-layout-1.png" width=350px class="center" style="padding:15px">

<h2>QScreen as a Html Container Element</h2>

<p>A key differeence between Qt for WebAssembly and Qt on ther platforms is that QScreen does not map to a physical screen. Instead, it maps to a html container element somewhere on the html document. It retains key "screen" properties where QScreen is a container for application windows, with externally specified geometry.
    
<p>Window management within the QScreen is similar to other platforms. Windows in Qt::WindowFullScreen mode use the enitre QScreen area and do not have window decorations, while windows in normal mode do have window decorations and can be moved and resized by the user.
    
<p>The integration point between QScreen and the html document is a div container element. QScreen will take the geometry of the div container element, and Qt will populate it with child elements depending on window configuraiton. One of the child elements will typically be a canvas element, other elemens include visually hidden accessibility elements and window management elements. Earlier versions of Qt used a canvas element as the integration point, however this is now deprecated and applications should use div elements instead. 

<img src="document-layout-2.png" width=350px class="center" style="padding:15px">

<h2>Using a single container elment</h2>

<p>The above describes the general case with multiple Qt container with mixed html and Qt application content. Often, we'd like the applicaiton to use the full size of the browser window. This is done by configuring the web document and Qt container to use the entire viewport area.
    
<img src="document-layout-3.png" width=350px class="center" style="padding:15px">

<p>The default html generated by Qt uses this configuration. Window management is simple in this case; the app calls show() on the window which makes the it use the entire QScreen and html viewport area.

<h2>Using multiple container elements</h2>

<p>The <a href=https://git.qt.io/mosorvig/qt-web-utils>Qt Web utils</a> repository contains several examples which shows how to customize html document integration. We'll take a look at some code examples here where we look at how to write html and JavaScript which configures Qt to use one or more container elements.
    
<p>The following section uses application and html code from the <a href=https://git.qt.io/mosorvig/qt-web-utils/-/blob/main/examples/multiple_windows_simple/index.html>multiple_windows_simple</a> example, which looks like this in the browser:
    
<img src="multiple_windows.jpg" width=600px class="center">
    
<p>The page contains two html container elements, which are given a size and then laid out using the browser's html layout engine:

<p class="code">    &lt;body&gt;
        &lt;div class="container" style="width:320px; height:200px"&gt;&lt;/div&gt;
        &lt;div class="container" style="width:320px; height:200px"&gt;&lt;/div&gt;
    &lt;/body&gt;
</p class="code">

<p>The container elements are looked up at page load time and passsed to QtLoader:

<p class="code">    window.addEventListener('load', () => {
        const containers = document.querySelectorAll("div.container")
        const qtloader = QtLoader {
            containerElements : Array.from(containers),
            showLoader: () => {}, // disable loading notification (optional)
        }
        qtloader.load("myapp");
    });
</p>


<p>Finally, application C++ code must assign windows to screens by iterating over over <a href=https://doc.qt.io/qt-5/qguiapplication.html#screens>QGuiApplicaiton::screens()</a>:

<p class="code">    foreach(QScreen *screen: qApp->screens()) {
        QWindow *appWindow = new QAppWindow();
        appWindow->setScreen(screen);
        appWindow->show();
    }
</p class="code">

<p>QWindow::show() behaves like showMaximized() on Qt for WebAssembly, similar to Qt for iOS and Android.
    
<h2>Adding Container Elements at Runtime</h2>

<p>QtLoader supports adding and removing container elements and screens at runtime:
<p class="code">    let qtloader = ...;
    
    fn addContainer(containerId) {
        const element = document.getElementById(containerId);
        qtloader.addContainerElement(element);    
    }

    fn RemoveContainer(containerId) {
        const element = document.getElementById(containerId");
        qtloader.removeContainerElement(element);    
    }
</p>

<p>The applicationthen connects to the <a  href=https://doc.qt.io/qt-5/qguiapplication.html#screenAdded>QGuiApplicaiton::screenAdded()</a> and <a href=https://doc.qt.io/qt-5/qguiapplication.html#screenRemoved> QGuiApplicaiton::screenRemoved()</A> where it adds or removes windows.
    
<p class="code">    QHash&lt;QScreen *, QWindow *&gt; g_windows; // one window per sceen
    
    connect(qApp, &QGuiApplication::screenAdded, [](QScreen *screen){
        QWindow *window = new AppWindow();
        window->setScreen(screen);
        window->show();
        g_windows.insert(screen, window);
    });

    connect(qApp, &QGuiApplication::screenRemoved, [](QScreen *screen){
        QWindow *window = g_windows.take(screen);
        window->hide()
        delete window;
    });

</p>

<p>The <a href=https://git.qt.io/mosorvig/qt-web-utils/-/blob/main/examples/multiple_windows>multiple_windows</a> example demonstrates adding and remove windows at runtime using a simple window manager:

<img src="multiple_windows2.jpg" width=600px class="center">

<h2>Using multiple browser windows or tabs</h2>

<p>Web applicaitons are capable of opening additional browser windows or tabs, with some limitations in order to prevent pages from creating too many annoying popups. Creating an additional browser window creates an additional document as well, with its own viewport.

<img src="document-layout-4.png" width=450px class="center" style="padding:15px">

<p>The second window can then access the qtloader object from the first window, by making use of the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/opener">window.opener()</a> API:
    
<p class="code">    window.onload = () => {
        const container = document.getElementById("container");
        window.opener.qtloader.addContainerElement(container);
    }

<p> Qt Web Utils provides the <a href=https://git.qt.io/mosorvig/qt-web-utils/-/blob/main/qtwebutils.h#L26>openBrowserWindow()</a> utility function for opening a new window or tab. Behind the scenes, this function uses emscripten::val to call the native <a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/open">window.open()</a> API:
    
<p class="code">emscripten::val openBrowserWindow(const QString& source, const QString &name, QSize size)
{
    QString features = QString("height=%2, width=%1 ").arg(size.width()).arg(size.height());
    emscripten::val window = emscripten::val::global("window");
    emscripten::val popup = window.call&lt;emscripten::val&gt;(
        "open", source.toStdString(), name.toStdString(), features.toStdString());
    return popupWindow;
}
</p>

<p>Placing windows on secondary html documents requires Qt 6.5 or higher, where we have refactored the implementation to make use of the <a href=https://emscripten.org/docs/api_reference/html5.h.html#registration-functions> specialHTMLTargets</a> functionality from Emscritpen in order to work around its limitation of supporting one html document only.

<p>The <a href=https://git.qt.io/mosorvig/qt-web-utils/-/tree/main/examples/popup_window>popup_window</a> example demonstrates how this works in practice:

<img src="popup_window.jpg" width=600px class="center">    

<h2>That's it!</h2>

<p>With this is should be possible to create both simple and complex html document integrations. Is there something we have missed or which is uclear? Let me know in the comments.
    

</html>